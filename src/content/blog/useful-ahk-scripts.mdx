---
title: 'Полезные скрипты AutoHotKey'
description: ''
date: 2023-07-18
---

import Alert from '@/components/Alert.astro'

## Оффициальный пример работы с окнами с Alt+ПКМ/Alt+ЛКМ

<Alert>[Источник](https://www.autohotkey.com/docs/v1/scripts/index.htm#EasyWindowDrag_(KDE))</Alert>

```
; Easy Window Dragging -- KDE style (requires XP/2k/NT) -- by Jonny
; https://www.autohotkey.com
; This script makes it much easier to move or resize a window: 1) Hold down
; the ALT key and LEFT-click anywhere inside a window to drag it to a new
; location; 2) Hold down ALT and RIGHT-click-drag anywhere inside a window
; to easily resize it; 3) Press ALT twice, but before releasing it the second
; time, left-click to minimize the window under the mouse cursor, right-click
; to maximize it, or middle-click to close it.

; This script was inspired by and built on many like it
; in the forum. Thanks go out to ck, thinkstorm, Chris,
; and aurelian for a job well done.

; Change history:
; November 07, 2006: Optimized resizing code in !RButton, courtesy of bluedawn.
; February 05, 2006: Fixed double-alt (the ~Alt hotkey) to work with latest versions of AHK.

; The Double-Alt modifier is activated by pressing
; Alt twice, much like a double-click. Hold the second
; press down until you click.
;
; The shortcuts:
;  Alt + Left Button  : Drag to move a window.
;  Alt + Right Button : Drag to resize a window.
;  Double-Alt + Left Button   : Minimize a window.
;  Double-Alt + Right Button  : Maximize/Restore a window.
;  Double-Alt + Middle Button : Close a window.
;
; You can optionally release Alt after the first
; click rather than holding it down the whole time.

If (A_AhkVersion < "1.0.39.00")
{
    MsgBox,20,,This script may not work properly with your version of AutoHotkey. Continue?
    IfMsgBox,No
    ExitApp
}


; This is the setting that runs smoothest on my
; system. Depending on your video card and cpu
; power, you may want to raise or lower this value.
SetWinDelay,2

CoordMode,Mouse
return

!LButton::
If DoubleAlt
{
    MouseGetPos,,,KDE_id
    ; This message is mostly equivalent to WinMinimize,
    ; but it avoids a bug with PSPad.
    PostMessage,0x112,0xf020,,,ahk_id %KDE_id%
    DoubleAlt := false
    return
}
; Get the initial mouse position and window id, and
; abort if the window is maximized.
MouseGetPos,KDE_X1,KDE_Y1,KDE_id
WinGet,KDE_Win,MinMax,ahk_id %KDE_id%
If KDE_Win
    return
; Get the initial window position.
WinGetPos,KDE_WinX1,KDE_WinY1,,,ahk_id %KDE_id%
Loop
{
    GetKeyState,KDE_Button,LButton,P ; Break if button has been released.
    If KDE_Button = U
        break
    MouseGetPos,KDE_X2,KDE_Y2 ; Get the current mouse position.
    KDE_X2 -= KDE_X1 ; Obtain an offset from the initial mouse position.
    KDE_Y2 -= KDE_Y1
    KDE_WinX2 := (KDE_WinX1 + KDE_X2) ; Apply this offset to the window position.
    KDE_WinY2 := (KDE_WinY1 + KDE_Y2)
    WinMove,ahk_id %KDE_id%,,%KDE_WinX2%,%KDE_WinY2% ; Move the window to the new position.
}
return

!RButton::
If DoubleAlt
{
    MouseGetPos,,,KDE_id
    ; Toggle between maximized and restored state.
    WinGet,KDE_Win,MinMax,ahk_id %KDE_id%
    If KDE_Win
        WinRestore,ahk_id %KDE_id%
    Else
        WinMaximize,ahk_id %KDE_id%
    DoubleAlt := false
    return
}
; Get the initial mouse position and window id, and
; abort if the window is maximized.
MouseGetPos,KDE_X1,KDE_Y1,KDE_id
WinGet,KDE_Win,MinMax,ahk_id %KDE_id%
If KDE_Win
    return
; Get the initial window position and size.
WinGetPos,KDE_WinX1,KDE_WinY1,KDE_WinW,KDE_WinH,ahk_id %KDE_id%
; Define the window region the mouse is currently in.
; The four regions are Up and Left, Up and Right, Down and Left, Down and Right.
If (KDE_X1 < KDE_WinX1 + KDE_WinW / 2)
    KDE_WinLeft := 1
Else
    KDE_WinLeft := -1
If (KDE_Y1 < KDE_WinY1 + KDE_WinH / 2)
    KDE_WinUp := 1
Else
    KDE_WinUp := -1
Loop
{
    GetKeyState,KDE_Button,RButton,P ; Break if button has been released.
    If KDE_Button = U
        break
    MouseGetPos,KDE_X2,KDE_Y2 ; Get the current mouse position.
    ; Get the current window position and size.
    WinGetPos,KDE_WinX1,KDE_WinY1,KDE_WinW,KDE_WinH,ahk_id %KDE_id%
    KDE_X2 -= KDE_X1 ; Obtain an offset from the initial mouse position.
    KDE_Y2 -= KDE_Y1
    ; Then, act according to the defined region.
    WinMove,ahk_id %KDE_id%,, KDE_WinX1 + (KDE_WinLeft+1)/2*KDE_X2  ; X of resized window
                            , KDE_WinY1 +   (KDE_WinUp+1)/2*KDE_Y2  ; Y of resized window
                            , KDE_WinW  -     KDE_WinLeft  *KDE_X2  ; W of resized window
                            , KDE_WinH  -       KDE_WinUp  *KDE_Y2  ; H of resized window
    KDE_X1 := (KDE_X2 + KDE_X1) ; Reset the initial position for the next iteration.
    KDE_Y1 := (KDE_Y2 + KDE_Y1)
}
return

; "Alt + MButton" may be simpler, but I
; like an extra measure of security for
; an operation like this.
!MButton::
If DoubleAlt
{
    MouseGetPos,,,KDE_id
    WinClose,ahk_id %KDE_id%
    DoubleAlt := false
    return
}
return

; This detects "double-clicks" of the alt key.
~Alt::
DoubleAlt := A_PriorHotkey = "~Alt" AND A_TimeSincePriorHotkey < 400
Sleep 0
KeyWait Alt  ; This prevents the keyboard's auto-repeat feature from interfering.
return
```

## Скрипты для работы с окнами с Хабра

<Alert>[Источник](https://habr.com/ru/articles/24652/)</Alert>

### Перемещение окон с Win + ЛКМ

```
#LButton::
CoordMode, Mouse
MouseGetPos, EWD_MouseStartX, EWD_MouseStartY, EWD_MouseWin
WinGetClass, EWD_Win_Class, ahk_id %EWD_MouseWin%
If EWD_Win_Class = ProgMan
Return
WinGet, State, MinMax, ahk_id %EWD_MouseWin%
If State = 1
{
SplashImage,, W160 H27 B1 FM8 WM400 CT000080,, Окно максимизировано,, Calibri
SetTimer, Remove_Splash, 600
Return

Remove_Splash:
SetTimer, Remove_Splash, Off
SplashImage, Off
Return
}
WinGetPos, EWD_OriginalPosX, EWD_OriginalPosY,,, ahk_id %EWD_MouseWin%
SetTimer, EWD_WatchMouse, 10
Return

EWD_WatchMouse:
EWD_Work = 1
GetKeyState, EWD_LButtonState, LButton, P
If EWD_LButtonState = U
{
SetTimer, EWD_WatchMouse, off
EWD_Work =
Return
}
GetKeyState, EWD_EscapeState, Escape, P
If EWD_EscapeState = D
{
SetTimer, EWD_WatchMouse, off
EWD_Work =
WinMove, ahk_id %EWD_MouseWin%,, %EWD_OriginalPosX%, %EWD_OriginalPosY%
Return
}
CoordMode, Mouse
MouseGetPos, EWD_MouseX, EWD_MouseY
WinGetPos, EWD_WinX, EWD_WinY,,, ahk_id %EWD_MouseWin%
SetWinDelay, -1
WinMove, ahk_id %EWD_MouseWin%,, EWD_WinX + EWD_MouseX - EWD_MouseStartX, EWD_WinY + EWD_MouseY - EWD_MouseStartY
EWD_MouseStartX := EWD_MouseX
EWD_MouseStartY := EWD_MouseY
Return
```

### Изменение размера окон с Win + ПКМ (немного подкорректирован)

```
LWin & RButton::
CoordMode, Mouse ; Switch to screen/absolute coordinates.
MouseGetPos, SWM_MouseStartX, SWM_MouseStartY, SWM_MouseWin
WinGetPos, SWM_WinX, SWM_WinY, SWM_WinW, SWM_WinH, ahk_id %SWM_MouseWin%
WinGetClass, SWM_Win_Class, ahk_id %SWM_MouseWin%
If SWM_Win_Class = ProgMan
Return
WinGet, State, MinMax, ahk_id %SWM_MouseWin%
If State = 1
{
SplashImage,, W160 H26 B1 FM8 WM400 CT000080,, Окно максимизировано,, Calibri
SetTimer, Remove_Splash, 600
Return

Remove_Splash:
SetTimer, Remove_Splash, Off
SplashImage, Off
Return
}
GetKeyState, SMW_LCtrlState, LCtrl
if SMW_LCtrlState=D
{
WinClose, ahk_id %SWM_MouseWin%
return
}
SWM_ResizeTypeX=0
SWM_ResizeTypeY=0
if (SWM_MouseStartX < SWM_WinX+SWM_WinW/2)
SWM_ResizeTypeX=1
if (SWM_MouseStartY < SWM_WinY+SWM_WinH/2)
SWM_ResizeTypeY=1
SetTimer, SWM_WatchMouse_Resize, 10
return

SWM_WatchMouse_Move:
GetKeyState, SMW_LButtonState, LButton, P
if SMW_LButtonState = U
{
SetTimer, SWM_WatchMouse_Move, off
return
}
Gosub SWM_GetMouseAndWindowPos
SWM_WinX += %SWM_DeltaX%
SWM_WinY += %SWM_DeltaY%
SetWinDelay, -1
WinMove, ahk_id %SWM_MouseWin%,, %SWM_WinX%, %SWM_WinY%
return

SWM_WatchMouse_Resize:
GetKeyState, SMW_RButtonState, RButton, P
if SMW_RButtonState = U
{
SetTimer, SWM_WatchMouse_Resize, off
return
}
Gosub SWM_GetMouseAndWindowPos
if SWM_ResizeTypeX
{
SWM_WinX += %SWM_DeltaX%
SWM_WinW -= %SWM_DeltaX%
}
else
SWM_WinW += %SWM_DeltaX%
if SWM_ResizeTypeY
{
SWM_WinY += %SWM_DeltaY%
SWM_WinH -= %SWM_DeltaY%
}
else
SWM_WinH += %SWM_DeltaY%
SetWinDelay, -1
WinMove, ahk_id %SWM_MouseWin%,, %SWM_WinX%, %SWM_WinY%, %SWM_WinW%, %SWM_WinH%
return

SWM_GetMouseAndWindowPos:
CoordMode, Mouse
MouseGetPos, SWM_MouseX, SWM_MouseY
SWM_DeltaX = %SWM_MouseX%
SWM_DeltaX -= %SWM_MouseStartX%
SWM_DeltaY = %SWM_MouseY%
SWM_DeltaY -= %SWM_MouseStartY%
SWM_MouseStartX = %SWM_MouseX%
SWM_MouseStartY = %SWM_MouseY%
WinGetPos, SWM_WinX, SWM_WinY, SWM_WinW, SWM_WinH, ahk_id %SWM_MouseWin%
return

```
